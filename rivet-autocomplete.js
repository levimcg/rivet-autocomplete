(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.RivetAutocomplete = factory());
}(this, (function () { 'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function setAttribute(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy,
		get,
		fire,
		on,
		set,
		_recompute: noop,
		_set,
		_stage,
		_mount,
		_differs
	};

	/* src/RivetAutocomplete.html generated by Svelte v2.16.1 */

	/**
	 * Copyright (C) 2019 The Trustees of Indiana University
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function labelFor({label}) {
		return label.replace(/\s+/g, '-').toLowerCase();
	}

	function currentMatch({activeDecendant, matches}) {
	  return matches[activeDecendant] || 'Nothing ';
	}

	function data() {
	  return {
	    menuVisible: false,
	    inputValue: '',
	    dataSet: [],
	    matches: [],
	    activeDecendant: null,
	    thereshold: 0,
	    matchStrategy: null
	  }
	}
	var methods = {
	  open() {
	    this.set({
	      menuVisible: true
	    });
	  },
	  
	  close() {
	    this.set({
	      menuVisible: false,
	      matches: [],
	      activeDecendant: null
	    });  
	  },
	  
	  handleResultClick(match, index) {
	    this.set({
	      inputValue: match,
	      menuVisible: false,
	      matches: []
	    });
	    
	    this.dispatchSelection(match);
	  },
	  
	  handleClickOutside(event) {
	    /**
	     * If the menu isn't visible the ref hasn't been created, so bail.
	     */
	    if (!this.refs.menu) return;
	    
	    /**
	     * This checks to make sure that the event target was NOT the menu,
	     * anything inside the menu, or the input itself. If it wasn't
	     * then it closes the menu. This makes it so the menus closes
	     * when the user clicks anywhere outside of it.
	     */
	    if (event.target !== this.refs.menu && event.target !== this.refs.inputEl && !this.refs.menu.contains(event.target)) {
	      this.close();
	    }
	  },
	  
	  handleInput(event) {
	    if (this.get().inputValue === '') {
	      this.close();
	      
	      return;
	    }
	    
	    if (this.get().inputValue.length > this.get().threshold) {
	      this.set({ matches: this.findMatches() });
	    }
	  },
	  
	  handleKeydown(event) {
	    var KEYS = {
	      end: 35,
	      left: 37,
	      up: 38,
	      right: 39,
	      down: 40,
	      tab: 9,
	      escape: 27,
	      enter: 13,
	      space: 32
	    };
	    
	    switch (event.keyCode) {
	      case KEYS.down:
	        /**
	         * If the menu is already visible proceed with keyboard
	         * handling the down key.
	         */
	        if (this.get().activeDecendant === null && this.get().menuVisible) {
	          this.set({
	            activeDecendant: 0
	          });
	        } else {
	          this.set({
	            activeDecendant: this.get().activeDecendant + 1
	          });
	          
	          if (this.get().activeDecendant >= this.get().matches.length) {
	            this.set({activeDecendant: 0});
	          }
	        }
	        break;
	      case KEYS.up:
	        this.set({
	          activeDecendant: this.get().activeDecendant - 1
	        });
	          
	        if (this.get().activeDecendant <= -1) {
	          this.set({
	            activeDecendant: this.get().matches.length -1
	          });
	        }
	        break;
	      case KEYS.escape:
	        this.close();
	        
	        break;
	      case KEYS.tab:
	        this.close();
	        
	        break;
	      case KEYS.enter:
	        var activeMatch = this.get().matches[this.get().activeDecendant];
	        
	        if (!activeMatch) return;
	        
	        this.set({
	          inputValue: activeMatch
	        });
	        
	        this.dispatchSelection(activeMatch);
	        
	        this.close();
	        
	        break;
	      default:
	        break;
	    }
	  },
	  
	  dispatchSelection(textContent) {
	    this.fire('item-selected', {
	      item: textContent
	    });
	  },
	  
	  findMatches() {
	    this.open();
	    
	    if(this.get().matchStrategy) {
	      return this.get().matchStrategy(this.get().dataSet, this.get().inputValue);
	    } else {
	      /**
	       * Default match strategy
	       */
	      var wordMatch = new RegExp(this.get().inputValue, 'gi');
	      
	      return this.get().dataSet.filter(function(item) {
	        return item.match(wordMatch);
	      });
	    }
	    
	  }
	};

	function oncreate() {
	  /**
	   * Need to bind this method when the component is created
	   * so that it preserves the correct context for "this" when
	   * we use it later.
	   */
	  this.handleClickOutside = this.handleClickOutside.bind(this);
	  
	  // Add event listener for refs
	  document.addEventListener('click', this.handleClickOutside, false);
	}
	function ondestroy() {
	  // clean up eventListeners
	  document.removeEventListener('click', this.handleClickOutside, false);
	}
	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.handleResultClick(ctx.match, ctx.index);
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.match = list[i];
		child_ctx.index = i;
		return child_ctx;
	}

	function create_main_fragment(component, ctx) {
		var div1, div0, text0, label, text1, text2, input, input_updating = false, input_aria_activedescendant_value, text3, div1_aria_expanded_value;

		var if_block0 = (ctx.menuVisible) && create_if_block_2(component, ctx);

		function input_input_handler() {
			input_updating = true;
			component.set({ inputValue: input.value });
			input_updating = false;
		}

		function input_handler(event) {
			component.handleInput(event);
		}

		function keydown_handler(event) {
			component.handleKeydown(event);
		}

		var if_block1 = (ctx.menuVisible) && create_if_block(component, ctx);

		return {
			c() {
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n  ");
				label = createElement("label");
				text1 = createText(ctx.label);
				text2 = createText("\n  ");
				input = createElement("input");
				text3 = createText("\n  ");
				if (if_block1) if_block1.c();
				div0.className = "rvt-sr-only";
				setAttribute(div0, "aria-live", "polite");
				label.htmlFor = ctx.labelFor;
				addListener(input, "input", input_input_handler);
				addListener(input, "input", input_handler);
				addListener(input, "keydown", keydown_handler);
				setAttribute(input, "aria-activedescendant", input_aria_activedescendant_value = ctx.activeDecendant !== null ? 'result-' + ctx.activeDecendant : null);
				input.id = ctx.labelFor;
				input.autocomplete = "off";
				setAttribute(input, "type", "text");
				div1.className = "rvt-autocomplete";
				setAttribute(div1, "role", "combobox");
				setAttribute(div1, "aria-expanded", div1_aria_expanded_value = ctx.menuVisible ? 'true' : 'false');
			},

			m(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div1, text0);
				append(div1, label);
				append(label, text1);
				append(div1, text2);
				append(div1, input);
				component.refs.inputEl = input;

				input.value = ctx.inputValue;

				append(div1, text3);
				if (if_block1) if_block1.m(div1, null);
			},

			p(changed, ctx) {
				if (ctx.menuVisible) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_2(component, ctx);
						if_block0.c();
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (changed.label) {
					setData(text1, ctx.label);
				}

				if (changed.labelFor) {
					label.htmlFor = ctx.labelFor;
				}

				if (!input_updating && changed.inputValue) input.value = ctx.inputValue;
				if ((changed.activeDecendant) && input_aria_activedescendant_value !== (input_aria_activedescendant_value = ctx.activeDecendant !== null ? 'result-' + ctx.activeDecendant : null)) {
					setAttribute(input, "aria-activedescendant", input_aria_activedescendant_value);
				}

				if (changed.labelFor) {
					input.id = ctx.labelFor;
				}

				if (ctx.menuVisible) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block(component, ctx);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if ((changed.menuVisible) && div1_aria_expanded_value !== (div1_aria_expanded_value = ctx.menuVisible ? 'true' : 'false')) {
					setAttribute(div1, "aria-expanded", div1_aria_expanded_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block0) if_block0.d();
				removeListener(input, "input", input_input_handler);
				removeListener(input, "input", input_handler);
				removeListener(input, "keydown", keydown_handler);
				if (component.refs.inputEl === input) component.refs.inputEl = null;
				if (if_block1) if_block1.d();
			}
		};
	}

	// (3:4) {#if menuVisible}
	function create_if_block_2(component, ctx) {
		var text_value = `${ctx.matches.length} of a possible ${ctx.dataSet.length} are available.
    ${ctx.currentMatch} (${ctx.matches.indexOf(ctx.currentMatch) + 1} of ${ctx.matches.length}) is selected.`, text;

		return {
			c() {
				text = createText(text_value);
			},

			m(target, anchor) {
				insert(target, text, anchor);
			},

			p(changed, ctx) {
				if ((changed.matches || changed.dataSet || changed.currentMatch) && text_value !== (text_value = `${ctx.matches.length} of a possible ${ctx.dataSet.length} are available.
    ${ctx.currentMatch} (${ctx.matches.indexOf(ctx.currentMatch) + 1} of ${ctx.matches.length}) is selected.`)) {
					setData(text, text_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (19:2) {#if menuVisible}
	function create_if_block(component, ctx) {
		var div;

		function select_block_type(ctx) {
			if (ctx.matches.length < 1) return create_if_block_1;
			return create_else_block;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c() {
				div = createElement("div");
				if_block.c();
				div.className = "rvt-box rvt-box--compact rvt-box--card rvt-autocomplete__results";
			},

			m(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
				component.refs.menu = div;
			},

			p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
				if (component.refs.menu === div) component.refs.menu = null;
			}
		};
	}

	// (25:4) {:else}
	function create_else_block(component, ctx) {
		var each_anchor;

		var each_value = ctx.matches;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p(changed, ctx) {
				if (changed.activeDecendant || changed.matches) {
					each_value = ctx.matches;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (21:4) {#if matches.length < 1}
	function create_if_block_1(component, ctx) {
		var span, text_value = ctx.noResultsText || 'Sorry, no results found', text;

		return {
			c() {
				span = createElement("span");
				text = createText(text_value);
				span.className = "rvt-autocomplete__result rvt-autocompleted__result--empty";
			},

			m(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p(changed, ctx) {
				if ((changed.noResultsText) && text_value !== (text_value = ctx.noResultsText || 'Sorry, no results found')) {
					setData(text, text_value);
				}
			},

			d(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (26:6) {#each matches as match, index}
	function create_each_block(component, ctx) {
		var span, text0_value = ctx.match, text0, text1, span_class_value;

		return {
			c() {
				span = createElement("span");
				text0 = createText(text0_value);
				text1 = createText("\n      ");
				span._svelte = { component, ctx };

				addListener(span, "click", click_handler);
				span.className = span_class_value = "rvt-autocomplete__result " + (ctx.index === ctx.activeDecendant ? ' active' : '');
				setAttribute(span, "role", "option");
				span.id = "result-" + ctx.index;
			},

			m(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				append(span, text1);
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if ((changed.matches) && text0_value !== (text0_value = ctx.match)) {
					setData(text0, text0_value);
				}

				span._svelte.ctx = ctx;
				if ((changed.activeDecendant) && span_class_value !== (span_class_value = "rvt-autocomplete__result " + (ctx.index === ctx.activeDecendant ? ' active' : ''))) {
					span.className = span_class_value;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(span);
				}

				removeListener(span, "click", click_handler);
			}
		};
	}

	function RivetAutocomplete(options) {
		init(this, options);
		this.refs = {};
		this._state = assign(data(), options.data);

		this._recompute({ label: 1, activeDecendant: 1, matches: 1 }, this._state);
		this._intro = true;

		this._handlers.destroy = [ondestroy];

		this._fragment = create_main_fragment(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}
	}

	assign(RivetAutocomplete.prototype, proto);
	assign(RivetAutocomplete.prototype, methods);

	RivetAutocomplete.prototype._recompute = function _recompute(changed, state) {
		if (changed.label) {
			if (this._differs(state.labelFor, (state.labelFor = labelFor(state)))) changed.labelFor = true;
		}

		if (changed.activeDecendant || changed.matches) {
			if (this._differs(state.currentMatch, (state.currentMatch = currentMatch(state)))) changed.currentMatch = true;
		}
	};

	return RivetAutocomplete;

})));
